# Micro Frontends Architecture

독립적으로 제공 가능한 프론트엔드 애플리케이션이 더 큰 전체로 구성되는 아키텍처 스타일

> MSA(Microservices Architecture) - 마이크로서비스 아키텍처에서 각 애플리케이션은 더 작고 느슨하게 결합되고 독립적으로 배치 가능한 여러 서비스로 구성된다.

### Monolithic Frontend 와 Micro Frontends 비교

- 현재 대부분의 아키텍처에서 프론트엔드는 모놀리식한 단일 코드 베이스로 구성이 된다.
- Micro Frontends 는 Monolithic Frontend 와 비교하여 초기 개발 속도가 느리고, 빌드/배포 설정이 복잡하고,
  개발 환경 설정이 복잡하지만 커뮤니케이션 비용이 시스템이 커지는 것에 영향을 받지 않고 작으며,
  배포시간이 빠르고, 장애 파급 범위가 작으며, 자율성이 높다.
  | | Monolithic Frontend | Micro Frontends |
  | ----------------- | ---------------------- | --------------- |
  | 초기 개발 속도 | 빠르다 | 느리다 |
  | 빌드 / 배포 설정 | 단순 | 복잡 |
  | 개발 환경 설정 | 간단 | 복잡 |
  | 커뮤니케이션 비용 | 시스템이 커질수록 커짐 | 작다 |
  | 배포 시간 | 느리다 | 빠르다 |
  | 장애 파급 범위 | 크다 | 작다 |
  | 자율성 | 낮다 | 높다 |

## Micro Frontends 도입

### 문제 식별

- 모놀리스 프론트엔드 프로젝트에서 규모가 커지면서 나타나는 전조 증상
  - 코드를 수정한 후, 엉뚱한 곳에서 버그가 발생
  - 새로운 기능을 위해 기존 코드를 활용의 두려움
  - 간단한 수정 사항을 적용하기 위해 통합, 테스트, 빌드 및 배포 시간이 점차 증가
  - 작업을 위한 커뮤니케이션 비용 점차 증가
  - 동일한 기능을 제공하기 위해 여기 저기서 각각 개발하는 일이 증가
- 적절한 규모의 팀을 넘어서 이러한 전조 증상을 관리할 수 없다면, Micro Frontends 도입을 고려해야함

### 도입 장점

- 덜 복잡하고, 적은 양의 코드를 관리하여 코드의 품질을 높일 수 있다.
- 배포의 범위가 줄어들어 빌드 및 배포 시간이 줄고 위험도가 줄어든다.
- 단일 장애 지점 (Single Point Of Failure) 을 피할 수 있다.
- 점진적으로 업그레이드 하기에 용이하다.
- 요구사항에 맞춰 애플리케이션을 자유롭게 조립하여 제공할 수 있다.
- 독립적으로 개발 및 배포할 수 있기 때문에 오너십을 가진 팀이 자유롭게 스케줄을 조정할 수 있다.
- 팀이 주도적으로 자유롭게 기술 스택을 선택할 수 있다.
- 서로 다른 팀이 독립적으로 작업을 할 수 있기 때문에 개발 주기가 더 빨라질 수 있다.

### 도입 단점

- 중복 코드가 발생할 수 있다.
- 전체적인 리소스의 크기가 커져 성능 저하에 대한 주의가 필요하다.
- 초기 구축 비용이 발생한다.
- 다양한 마이크로 프론트엔드 간의 통합과 통신에서 추가적인 복잡성이 발생할 수 있다.
- 빌드 타임에서는 문제가 발생하지 않지만, 런타임에 동적으로 통합하는 과정에서 문제가 발생할 수 있다.
- 각각 자율적으로 발전하는 마이크로 프론트엔드 간의 일관적인 UX 제공을 위한 장치가 필요하다.
- 마이크로 프론트엔드마다 기술적인 격차가 벌어질 가능성이 있다.

### 도입이 필요한 경우

- 적절한 규모의 팀을 벗어난 경우
  - 마이크로 앱으로 분해하여 각 팀마다 개발할 인원이 충분한 경우
    - 프론트엔드 개발자가 많은 경우
    - 크로스 펑셔널 팀을 조직 가능한 경우
- 기능적으로 마이크로 앱으로 분해가 가능한 경우
  - 서비스가 URL 경로를 기준으로 기능적으로 구분이 가능한 경우
  - 어떤 팀이 어떤 부분에 책임을 가지고 있는지가 명확하게 구분이 가능해야함
    - 불분명하거나 중복된 부분이 발생하지 않아야함
- 런타임에 여러가지 마이크로 앱을 선택적으로 조립해서 제공해야 하는 경우
  - 런타임에 특정 버전을 사용하도록 처리 할 수 있음
- 마이크로 앱이 독립적으로 인프라 구성이 가능한 경우
  - 클라우드 자원을 충분히 활용 가능한 경우
  - _같은 서버에 서로 다른 마이크로 앱을 배포한 경우는 무의미_

## MFA 설계 핵심 원칙

### Micro Frontends 를 규정하는 가장 중요한 요소

- Micro Frontends 정의는 표현은 다르지만 다음의 두가지 핵심 원칙
  - 독립적으로 개발 및 운영이 가능한 마이크로 앱
  - 이러한 마이크로 앱 여러개를 합쳐 하나의 커다란 웹 애플리케이션을 제공
- Micro Frontends 에서 End-to-End Teams 은 시스템과 조직이 닮아가는 현상
- 현실적으로 바로 전환은 어려울 수 있기 때문에 BFF 와 같은 레이어를 활용하면서 점진적으로 변해가는 방식이 있음

### 서비스를 나누는 방법

- 기존 서비스가 있는 경우, 모든 페이지들을 나열하여 유형을 분류하고 유형별로 팀을 나눠 적당한 팀에게 오너십을 준다.
  한 페이지에 목적이 여러가지가 있는 경우는 조각으로 잘라내서 맞는 팀에서 나누어 준다.
- 고객의 요구사항을 중심으로 팀을 구성하고, 페이지와 조각을 분류하여 팀에게 오너십을 준다.
  고객의 요구사항을 명확하게 팀으로 만들지 못하면, 누락이 발생할 수 있다.
- 도메인 주도 설계의 도메인 논리와 바운디드 컨텍스트를 이용해서 팀의 경계를 설정한다.
  백엔드의 마이크로서비스 아키텍처가 견고한 경우 이점이 있을 수 있다.

## Micro Frontends 와 Monorepo

> _모노레포는 잘 정의된 관계를 가진 여러 개의 개별 프로젝트가 포함된 단일 리포지토리입니다_

### Monolith Repo

- 한 저장소에 하나의 앱에 관련된 모든 코드와 리소스를 넣는 방식
- 프로젝트 하나입니다. (React SPA 혹은 Next.js 등등)
- 프로젝트 하나 안에 페이지들, UI 컴포넌트들, 상태 관리 로직 및 데이터 처리 등 모든 것이 들어 있음
- Monorepo ≠ Monolith

### Modular Repo

- 소스 코드를 분류하여 여러개의 모듈로 나누고 모듈을 각각의 패키지로 만들어 패키지 간 필요한 패키지를 가져다 쓰는 방식
- 패키지간 잘 정의된 관계가 없다면 Monorepo 가 아님
- 이러한 패키지 간 잘 정의된 관계로 여러 패키지를 하나의 레포에서 관리하는 방식이 **Monorepo**

### Monorepo 와 Polyrepo

"_모듈로 나누어 연관 짓는다_" 라는 개념 아래서 하나의 레포로 관리하면 Monorepo, 모듈마다 레포를 가지고 관리하면 Polyrepo 혹은 Multirepo 라고 한다.

### Polyrepo 에서의 단점 => _Monorepo 에서의 장점_

- 이슈 수정을 하다가 라이브러리를 수정해야 해서 번거러운 일이 발생
- 히스토리가 한눈에 보이지 않음.
- 기존 코드를 활용하려면 추가적인 비용 발생
- 프로젝트를 새로 생성할 때, 비용 발생
- 각 프로젝트마다 설정이 일관적이지 않아 컨텍스트 스위칭과 유지보수 맥락이 끊김

### Monorepo 에서의 단점 => _Polyrepo 에서의 장점_

- 상대적으로 의존성 연결이 쉽기 때문에 과도한 의존 관계가 나타날 수 있음
- 하나의 CI 를 구성할 수는 있지만, 방법이 복잡할 수 있음
- 저장소 자체가 빠르게 무거워질 수 있음
- 모든 코드가 밀집되어 있어 사소한 문제가 크게 확대될 가능성이 있음

### Micro Frontends 에 Monorepo 가 반드시 필요할까??

당연히 반드시 필요한 것은 아니다. 그러나,

- 이슈 수정을 하다가 라이브러리를 수정해야 해서 번거러운 일이 발생하지 않음
  - 이슈 기반의 커밋
- 전체 히스토리가 한번에 보임
- 기존 코드를 활용할 때 드는 비용이 작음
- 프로젝트를 새로 생성할 때, 비용이 작음
- 각 프로젝트마다 설정이 일관적이고 같은 DX(개발자경험) 를 가질 수 있음
- 상대적으로 의존성 연결이 쉽기 때문에 과도한 의존 관계가 나타나지 않도록 주의해야함
- 방법이 복잡할 수 있지만 함께 하나의 CI 를 구성할 수는 있고 일관적인 DX 를 발전시킬 수 있음
- 모노레포 툴을 이용해서 성능에 주의를 기울일 수 있음
- 모든 코드가 밀집되어 있어 사소한 문제가 크게 확대될 가능성이 있음에 주의하고 여러군데서 사용하는 코드에 대해 여러 프로젝트 담당자들과 함께 충분한 의논 가능

## MFA 통합 방법

- [Server-side template composition](#server-side-template-composition)
- [Build-time integration](#build-time-integration)
- [Run-time integration via Ajax](#run-time-integration-via-ajax)
- [Run-time integration via `<iframes />`](#run-time-integration-via-iframes)
- [Run-time integration via Web Components](#run-time-integration-via-web-components)
- [Run-time integration via JavaScript](#run-time-integration-via-javascript)
- [Run-time integration via Module Federation](#run-time-integration-via-module-federation)
- [Linked SPA & Unified SPA](#linked-spa--unified-spa)

### Server-side template composition

각각 다른 앱에 맞는 HTML을 서빙하는 서버를 뒤에 두고, 요청한 URL에 따라 맞는 HTML들을 라우팅해주는 웹서버(ex: nginx 서버)를 그 앞에다가 놓아서, 맞는 HTML을 응답으로 보내주는 구조

- [서버에서 proxy 를 이용한 여러 페이지 통합](./integration/run-time-integration-nginx-proxy.md)

### Build-time integration

분리된 UI를 패키징해 배포하고 빌드타임에 통합시키는 방법

### Run-time integration via Ajax

ajax를 이용한 템플릿 통합 방식

- [런타임 ajax 통합](./integration/run-time-integration-ajax.md)

### Run-time integration via iframes

실행환경에서 배포단위를 UI 단위로 분리, 다른 웹앱의 UI 일부를 다른 웹 앱 안으로 통합

- 장점
  - iframe 은 모든 브라우저에서 작동
  - 강력한 기술적 격리를 제공: script, style
- 단점
  - 크기 조절이 어려워 반응형 레이아웃에 어려움 존재
  - 새로운 컨텍스트를 만들어 성능 오버헤드가 발생 가능성 보유
  - 접근성 문제가 발생 가능성 보유
  - SEO 에 좋지 않은 영향이 생길 수 있음
  - iframe 안의 콘텐츠가 멈추거나 지연될 수 있어 사용자 경험이 저하될 수 있음
  - 보안에 취약할 수 있음

### Run-time integration via Web Components

web 스펙인 web-components를 이용한 런타임 통합 방식

- 웹 컴포넌트가 해결해야할 목표

  - **Custom elements**: 사용자 인터페이스에서 원하는대로 사용할 수있는 사용자 정의 요소 및 해당 동작을 정의 할 수있는 JavaScript API 세트
  - **Shadow DOM**: 캡슐화된 "그림자" DOM 트리를 엘리먼트(_메인 다큐먼트 DOM 으로부터 독립적으로 렌더링 되는_)를 추가하고 연관된 기능을 제어하기 위한 JavaScript API 의 집합.
    이 방법으로 엘리먼트의 기능을 프라이빗하게 유지할 수 있어, 다큐먼트의 다른 부분과의 충돌에 대한 걱정 없이 스크립트와 스타일을 작성할 수 있음
    **HTML 템플릿**: `<template>` 과 `<slot>` 엘리먼트는 렌더링된 페이지에 나타나지 않는 마크업 템플릿을 작성할 수 있게함. 그 후, 커스텀 엘리먼트의 구조를 기반으로 여러번 재사용할 수 있음

- 장점

  - 널리 구현되어 있는 웹표준
  - 커스텀 엘리먼트와 Shadow DOM 모두 기존에는 할 수 없던 isolation 기능을 보유
  - 커스텀 엘리먼트의 생명주기 메서드들은 여러 다른 application 의 코드들을 표준화된 방법으로 감싸서 사용할 수 있음

- 단점
  - 클라이언트 단에서 JS가 동작해야함. (_서버사이드 렌더링 만으로는 불가_)
  - 구형 브라우저에 대응을 해야한다면 Shadow DOM 을 사용하기는 다소 어려움

### Run-time integration via JavaScript

- 가장 유연하고 팀에서 가장 자주 채택하는 방식
- 각 마이크로 프론트엔드는 `<script>` 태그를 사용하여 페이지에 포함되며, 로드 시 전역 함수를 진입점으로 노출
- 그런 다음 컨테이너 애플리케이션은 어떤 마이크로 프론트엔드를 마운트할지 결정하고 관련 함수를 호출하여 마이크로 프론트엔드에 렌더링할 시기와 위치를 알려줌

### Run-time integration via Module Federation

요즘 이게 좋다던데.

### Linked SPA & Unified SPA

각 앱간의 연결방식에 따른 spa. 앱 내부에서 뿐만 아니고 앱 간 링크도 soft로 되어있다면 상당히 높은 사용자경험을 제공할 수 있고, 상태값도 서로 공유할 수 있다.
