# TCP / IP

인터넷에서 컴퓨터들이 서로 정보를 주고 받는데 쓰이는 프로토콜의 집합

> **인터넷이란**
>
> - 전 세계에 걸쳐 파일 전송 등의 데이터 통신 서비스를 받을 수 있는 컴퓨터 네트워크 시스템
>
> **프로토콜**
>
> - 네트워크 통신을 위해 미리 정해놓은 공통된 메뉴얼

## TCP/IP 계층

- [Application Layer](#application-layer)
- [Transport Layer](#transport-layer)
- [Internet Layer](#internet-layer)
- [Network Access Layer](#network-access-layer)

### Application Layer

특정 서비스를 제공하기 위해 어플리케이션 간 정보를 주고 받을 수 있음 (_ex: HTTP 요청 및 응답을 통해 통신하는 것_)

- HTTP
- FTP
- SSH
- Telnet
- SMTP

### Transport Layer

송신된 데이터를 수신 측 어플리케이션에 확실하게 전달하게 함(_네트워크 통신을 하는 어플리케이션은 포트번호를 사용하게 되며, 포트번호를 사용해서 어플리케이션을 찾아주는 역할_)

- TCP
- UDP
- RTP
- RTCP

### Internet Layer

수신 측까지 데이터를 전달(_송신측, 수신측 모두 IP 주소를 가지며, IP 주소를 바탕으로 올바른 목적지로 찾아갈 수 있도록 해줌_)

- IP
- ARP
- ICMP
- RARP
- OSPF

### Network Access Layer

네트워크에 직접 연결된 기기 간 전송(_물리적 주소인 MAC 주소 사용_)

- Ethernet
- PPP
- Token Ring

## TCP/IP 흐름

### `www.google.com` 을 웹브라우저에 입력하면 무슨일이 일어날까?

여기서는 각 계층 별로 Http, TCP, IP, Ethernet 프로토콜 사용한다고 가정
| Network Access Layer | Internet Layer | Transport Layer | Application Layer |
| -------------------- | -------------- | --------------- | ----------------- |
| Ethernet | IP | TCP | HTTP |

1. 구글 웹서버의 80 포트로 HTTP Request 메세지를 보냄 ➡️ (http)www.google.com(:80)
2. 해당 요청을 인터넷을 통해 구글서버로 전달하기 위해 각 계층에 필요한 정보가 담긴 패킷 생성 
    1. Http Request 
    2. TCP
        - SP(시작포트) : 내컴퓨터에서 만든 소켓의 포트번호 ➡️ 내 컴퓨터는 알고 있음
        - DP(목적지포트) : 80 (Well-Known Port Number) ➡️ 알고 있음
    3. IP 헤더 정보 생성
        - SA(시작 IP 주소) : 이미 알고 있음
        - DA(목적지 IP 주소) : 아직 알지 못함 ➡️ `www.google.com` 도메인 정보만 알고 있지만 DNS 프로토콜을 통해 도메인정보로 IP 주소를 알아낼 수 있음
            1. 브라우저는 OS 에게 domain 에 대한 IP 주소 정보를 요청
            2. OS 에서 DNS 서버로 요청 ➡️ DNS도 Http Request 와 비슷하게 도메인이 담긴 쿼리를 도메인 서버로 보냄
                - DNS 서버 주소는 이미 컴퓨터에 등록되어 있음
                - DNS 또한 HTTP 와 같은 어플리케이션 계층 프로토콜
                - DNS 는 53 포트 사용
            3. 도메인서버가 IP 주소 응답
                - DNS 는 Transport Layer 에서 UDP(비연결지향형) 프로토콜 사용
                    - UDP 는 헤더가 간단
                    - 포트번호 말고 다른게 없음
    4. Ethernet 프로토콜에 대한 헤더 생성 ➡️ 아직 MAC 주소를 모름
        > ※ ***목적지인 구글 웹서버의 MAC 주소가 필요할까?***    
        > 👉 _MAC 주소는 구글의 MAC주소가 아닌 물리적으로 연결된 출발지의 공유기 MAC 주소가 필요_
        1. 공유기를 통해 다른 네트워크와 연결 가능(**_=게이트웨이_**)
        2. 게이트웨이 IP 정보는 알 수 있음(`netstat` 명령어) 
        3. IP 주소를 MAC 주소로 바꿔주는 주소해석 프로토콜인 ARP 프로토콜 사용해서 MAC 주소를 알아냄

    > ※ **_TCP 는 연결지향형 프로토콜_** 
    > - TCP 프로토콜은 송신측과 수신측이 서로 연결되는 작업이 필요(👉 **_3 Way Handshaking_**)
    > - TCP 헤더 플래그(컨트롤 비트)들 사용 (SYN, ACK)
    >   1. 클라이언트는 서버에게 접속을 요청하는 SYN 패킷을 보냄
    >   2. 서버는 SYN  요청을 받고 클라이언트에게 요청을 수락한다는 ACK 와 SYN 플래그가 설정된 패킷을 보냄. 
    >   3. 클라이언트는 서버에게 다시 ACK 를 보냄
    >   4. 이제부터 연결이 이루어지고 데이터가 오감(3-way-handshaking 으로 연결 성립)
    > ※ NAT(Network Address Translation)
    > - private ip가 공유기를 통해 나갈 때, public ip 주소를 변환하여 나가는 작업
3. Routing
- 사용자의 공유기를 거치고, 구글서버에 도착하기 위해 여러 라우터를 거쳐야함
- 라우터는 네트워크와 네트워크를 연결해주는 역할
- 라우터가 목적지 경로를 찾아나가는 과정 👉 Routing

4. 라우팅을 거쳐 구글서버가 연결된 라우터까지 데이터 도착
5. 패킷의 IP헤더에 기록된 구글 서버 IP 주소를 통해 MAC 주소를 가져옴 ➡️ ARP 프로토콜 사용
    - ARP 는 라우터가 연결된 네트워크에 브로드캐스팅
    - 목적지 구글서버가 자신의 IP로 온 ARP 요청을 받고 MAC 주소 응답 ➡️ 목적지 구글서버의 MAC 주소를 알게 되었다면 물리적으로 데이터가 전달될 수 있는 상태가 됨
6. Transport Layer 의 port 번호는 80이 적혀있음
    - 80 포트를 사용하고 있는 어플리케이션에게 데이터를 전달해줘야함
7. Application Layer 까지오면 웹서버가 사용될 Http Request 데이터를 얻을 수 있게됨
8. 서버에서 정상적으로 Http Request 를 받고 응답을 리턴
9. `/` 애 매핑된 GET 요청을 처리해서 적절한 Html 을 응답
10. Http 요청과 응답과정이 끝나면 연결을 종료(_TCP 의 컨트롤 비트가 사용됨 👉 ACK, FIN 플래그 사용_)
    1. 클라이언트가 서버로 연결을 종료하겠다는 FIN 플래그 전송
    2. 서버는 클라이언트에게 ACK 메세지를 보내고 통신이 끝날 때까지 대기
    3. 서버가 통신이 끝나면 클라이언트로 FIN 을 보냄
    4. 클라이언트는 확인했다는 의미로 서버에게 ACK 보냄
    5. 연결 종료 완료 (4단계에 걸쳐 진행 👉 4-Way-Handshaking)
    > ※ **서버가 FIN 을 보내기 전 보냈던 데이터가 FIN 보다 늦게 도착 할 경우**
    > - 서버로 부터 FIN 을 수신했다고 클라이언트가 바로 연결된 소켓을 닫아버리면 FIN 을 보내기 전에 보낸 패킷은 영원히 클라이언트가 받을 수 없게 됨
    > - 클라이언트는 서버로부터 FIN 요청을 받더라도 일정시간동안 소켓을 닫지 않고, 혹시나 아직 도착하지 않은 잉여 패킷을 기다림
    > - 4-Way-Handshaking 과정이 완료되어도 소켓을 닫지않고 잉여패킷을 기다리는 상태 👉 TIME_WAT

## 신뢰할 수 있는 TCP
근래에 우리는 매우 큰 데이터를 주고 받음 ➡️ 한개의 패킷으로만 주고받기에는 상당한 무리가 있음 ➡️ 데이터를 잘게 쪼개서 보내게 되고 많은 패킷을 보내게 됨 ➡️ 이러한 패킷들은 매우 복잡한 인터넷을 통해 목적지로 이동   
**_신뢰할 수 있는 프로토콜인 TCP 는 이러한 복잡한 환경에서 데이터가 유실되지 않거나 올바른 순서대로 잘 도착할 수 있도록 해줌_**
- TCP 는 **흐름제어**, **오류제어**, **혼잡제어**를 통해 신뢰성있는 데이터 전송을 보장



