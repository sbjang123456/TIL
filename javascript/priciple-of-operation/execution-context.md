# Execution Context (실행 컨텍스트)

코드를 **실행**하는데 필요한 **환경**(_코드 실행에 영향을 주는 조건이나 상태_)을 제공하는 객체 👉 코드를 실행할 때 식별자를 더욱 효율적으로 결정하기 위한 수단으로써 필요한 정보를 한데 모아 제공하는 객체

## 자바 스크립트 코드 실행 시 실행 컨텍스트의 생성 순서

1. 자바스크립트 코드를 실행시키면 자바스크립트 엔진은 콜 스택에 전역 실행컨텍스트를 담음 (**_Record, Outer 포함_**)
2. 이 후, 전역에서 함수를 실행시킨다면 해당 함수의 실행컨텍스트가 콜 스택에 담김 (_콜스택에서는 가장 최근에 추가된 실행 컨텍스트만 활성화_)
3. 만약, 또 함수 내에서 다른 함수가 호출되면 그 함수에 대한 실행컨텍스트가 콜 스택에 담김
4. 순차적으로 활성화된 함수가 실행을 마치고 종료되면 실행컨텍스트가 사라짐
5. 모든 함수가 실행을 마치고 전역의 마지막 라인까지 모두 실행된다면 전역 실행컨텍스트도 사라짐

## 실행 컨텍스트의 구성

### Environment Record (환경 레코드)

식별자와 신별자에 바인딩된 값을 기록해두는 객체

#### 1. 생성 단계 (Creation Phase)

실행 컨텍스트 생성 및 선언문만 실행해서 환경 레코드에 기록 (👉 본격적인 실행에 앞서 스캔하고 준비하는 단계)

- 실행컨텍스트가 생성되면 전체 코드를 스캔하면서 선언할게 있는지 찾아보고 있다면 환경레코드에 새로운 식별자를 기록

#### 2. 실행 단계 (Execution Phase)

선언문 외 나머지 코드 순차적 실행 (_환경 레코드를 참조하거나 업데이트_)

- 필요한 경우 생성 단계에서 환경레코드에 기록해둔 정보를 참고하거나 업데이트

#### 환경 레코드를 통한 Hoisting (호이스팅) 현상

선언 라인 전에도 에러가 나지 않고 변수를 참조할 수 있는 현상 (선언문이 마치 최상단에 끌어올려진 듯한 현상)

> 이 현상의 발생 이유는 선언문이 있는 코드라인을 물리적으로 최상단에 끌어 올렸기 때문이 아닌, 자바스크립트 엔진이 먼저 전체 코드를 스캔하여 변수 같은 정보를 실행컨텍스트 어딘가(_[레코드](#environment-record-환경-레코드)_)에 미리 기록해놓기 때문

- Variable Hoisting (변수 호이스팅)

  - `var` : **선언** 단계에서는 메모리 공간을 확보해두고 메모리 주소에 식별자를 연결 후 식별자를 암묵적으로 `undefined` 값으로 **초기화** (**선언**과 **초기화** 동시 발생)
    1. 환경 레코드에 식별자를 등록하고 `undefined` 로 초기화
    2. 자바스크립트 엔진은 현재 활성화된 실행컨텍스트 내에 환경레코드를 참고하여 코드 상의 초기화 전 단계에도 문제없이 값을 출력해냄
    3. 이 후, 변수에는 할당이 실행되면 환경레코드의 바인딩된 값을 업데이트
    4. 해당 변수를 참조할 때는 역시 환경레코드를 참조해서 값을 결정 (_이 전에 변수할당이 발생하면 환경레코드의 바인딩된 값도 변경되어있음!_)
  - `let`, `const` : **선언**만 발생 후 undefined 로 **초기화 X** (_할당문 이전 까지는 변수에 아무런 값이 담기지 않고, 유효한 값을 읽어올 수 없음!_) 👉 **[일시적 사각지대 발생](#일시적-사각지대)**
    1. 환경 레코드에 식별자를 등록해두긴 하지만, 값을 초기화하지는 않음!
    2. 이 후, 선언문 이전에 해당 값을 참조하려고 한다면, **Reference Error** 발생
       > #### 일시적 사각지대
       >
       > - `let`, `const` 로 선언했을 때, 선언 이전에 식별자를 참조할 수 없는 구역

- Function Hoisting (함수 호이스팅)
  - Function Expression (함수 표현식)
    - `var` 키워드를 통해 함수를 변수에 담아 선언문 이전에 실행하려고 하면 환경 레코드의 기록되어있는 값은 `undefined` 이기 때문에 실행될 수 없어서 타입 에러가 발생
    - `let`, `const` 키워드를 통해 함수를 변수에 담는다면 변수 호이스팅에서처럼 환경 레코드에 기록된 값이 없기 때문에 **Reference Error** 가 발생
  - Function Declaration (함수 선언식)
    - `function` 키워드를 통해 함수를 선언하면 자바스크립트 엔진이 함수의 선언과 동시에 완성된 함수 객체를 생성해서 환경레코드에 기록되므로 **_선언 전에도 함수 사용 가능_**

### Outer Environment Reference (외부 환경 참조)

바깥 Lexical Environment (_렉시컬 환경 or 정적 환경_ 👉 **Record + Outer**) 참조

#### 식별자 결졍 (Identifier Resolution)

코드에서 변수나 함수의 값을 결정 (_Record 에서 먼저 찾고, 바로 위 Outer 참조로 이동하면서 찾아서 결정_)
(콜스택 안에 동일한 식별자가 여럿일 떄, 자바스크립트 엔진이 어떠헥 outer를 활용해서 의사결정)

#### JS Scope Chaining (스코프 체이닝)

식별자를 결정하기 위해 상위 스코프 렉시컬환경의 환경레코드로 점차적으로 찾아가는 과정

- **스코프 체인 (Scope Chain)**
  - 식별자를 결정할 때 활용하는 스코프들의 연결 리스트
- 자바스크립트 엔진은 새로 생성된 실행 컨텍스트에서 상위 렉시컬 환경을 참조할 수 있는 outer 를 현재 실행 컨텍스트에 저장
  (필요한 경우에 이전 실행 컨텍스트의 환경레코드에 저장된 식별자도 참조 가능)
- 원칙적으로 현재 활성화된 실행컥텍스트에서 식별자를 먼저 찾고 현재 활성화된 실행컨텍스트의 환경레코드를 확인해도 식별자를 찾지못하면 자바스크립트 엔진은 outer가 가리키는 상위 렉시컬환경에서 찾음
- outer가 가리키는 상위 렉시컬 환경의 끝인 전역 실행컨텍스트의 렉시컬 환경까지 와서도 찾지못하면, **Reference Error** 발생
- 이 때, *동일한 식별자로 인해 상위 스코프에서 선언된 식별자의 값이 가려지는 현상*을 **변수 섀도잉(Variable Shadowing)** 이라고 함
